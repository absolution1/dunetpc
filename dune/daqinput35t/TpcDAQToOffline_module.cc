////////////////////////////////////////////////////////////////////////
// Class:       TpcDAQToOffline
// Module Type: producer
// File:        TpcDAQToOffline_module.cc
//
// Generated at Mon Sep  1 10:00:30 2014 by Jonathan Davies using artmod
// from cetpkgsupport v1_06_02.
////////////////////////////////////////////////////////////////////////

// framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

// lbne-artdaq and lbne-raw-data includes
#include "lbne-raw-data/Overlays/TpcMilliSliceFragment.hh"
#include "lbne-raw-data/Services/ChannelMap/ChannelMapService.h"
#include "artdaq-core/Data/Fragment.hh"
#include "dune/RunHistory/DetPedestalDUNE.h"

// larsoft includes
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "larcore/Geometry/Geometry.h"
#include "tpcFragmentToRawDigits.h"
#include "utilities/UnpackFragment.h"

// C++
#include <memory>
#include <iostream>
#include <fstream>
#include <sstream>
#include <TTree.h>

const int MaxSamples  = 15000;
const int MaxChannels = 2048;

namespace DAQToOffline {
  class TpcDAQToOffline;
}

class DAQToOffline::TpcDAQToOffline : public art::EDProducer {
public:
  explicit TpcDAQToOffline(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TpcDAQToOffline(TpcDAQToOffline const &) = delete;
  TpcDAQToOffline(TpcDAQToOffline &&) = delete;
  TpcDAQToOffline & operator = (TpcDAQToOffline const &) = delete;
  TpcDAQToOffline & operator = (TpcDAQToOffline &&) = delete;
  void produce(art::Event & evt) override;
  void reconfigure(const fhicl::ParameterSet &pset);
  void printParameterSet();
  void beginJob() override;
private:
  void Reset();

  std::string fFragType;
  std::string fRawDataLabel;
  std::string fOutputDataLabel;
  bool fUseChannelMap;
  bool fDebug;
  bool fMakeTree;
  raw::Compress_t        fCompression;      ///< compression type to use
  unsigned int           fZeroThreshold;    ///< Zero suppression threshold

  art::ServiceHandle<lbne::ChannelMapService> fChannelMap;

  TTree* fTree;
  int DigSize;
  int NSamples;
  float Channel[MaxChannels];
  float ADCs[MaxChannels][MaxSamples];
  float Pedestal[MaxChannels];
};


DAQToOffline::TpcDAQToOffline::TpcDAQToOffline(fhicl::ParameterSet const & pset) {

  this->reconfigure(pset);

  produces< std::vector<raw::RawDigit> > (fOutputDataLabel);  

}

void DAQToOffline::TpcDAQToOffline::reconfigure(fhicl::ParameterSet const& pset) {

  fFragType = pset.get<std::string>("FragType");
  fRawDataLabel = pset.get<std::string>("RawDataLabel");
  fOutputDataLabel = pset.get<std::string>("OutputDataLabel");
  fUseChannelMap = pset.get<bool>("UseChannelMap");
  fDebug = pset.get<bool>("Debug");
  fMakeTree = pset.get<bool>("MakeTree");
  fZeroThreshold=0;
  fCompression=raw::kNone;
  if(fDebug) printParameterSet();

}

void DAQToOffline::TpcDAQToOffline::beginJob() {
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("FlatDigitTree","FlatDigitTree");
  fTree->Branch("NSamples",&NSamples,"NSamples/I"      );
  fTree->Branch("DigSize" ,&DigSize, "DigSize/I"      );
  fTree->Branch("Channel" ,&Channel ,"Channel[DigSize]/F" );
  fTree->Branch("Pedestal",&Pedestal,"Pedestal[DigSize]/F");
  fTree->Branch("ADCs"    ,&ADCs    ,"ADCs[DigSize][15000]/F");
}

void DAQToOffline::TpcDAQToOffline::printParameterSet(){

  for(int i=0;i<20;i++) std::cout << "=";
  std::cout << std::endl;
  std::cout << "Parameter Set" << std::endl;
  for(int i=0;i<20;i++) std::cout << "=";
  std::cout << std::endl;

  std::cout << "fFragType: " << fFragType << std::endl;
  std::cout << "fRawDataLabel: " << fRawDataLabel << std::endl;
  std::cout << "fOutputDataLabel: " << fOutputDataLabel << std::endl;
  std::cout << "fDebug: ";
  if(fDebug) std::cout << "true" << std::endl;
  else std::cout << "false" << std::endl;

  for(int i=0;i<20;i++) std::cout << "=";
  std::cout << std::endl;    


}

void DAQToOffline::TpcDAQToOffline::produce(art::Event & evt)
{
  art::Handle<artdaq::Fragments> rawFragments;
  evt.getByLabel(fRawDataLabel, fFragType, rawFragments);

  art::EventNumber_t eventNumber = evt.event();

  // Check if there is RCE data in this event
  // Don't crash code if not present, just don't save anything
  try { rawFragments->size(); }
  catch(std::exception e) {
    std::cout << "WARNING: Raw RCE data not found in event " << eventNumber << std::endl;
    std::vector<raw::RawDigit> digits;
    evt.put(std::make_unique<std::vector<raw::RawDigit>>(std::move(digits)), fOutputDataLabel);
    return;
  }

  //Check that the data is valid
  if(!rawFragments.isValid()){
    std::cerr << "Run: " << evt.run()
	      << ", SubRun: " << evt.subRun()
	      << ", Event: " << eventNumber
	      << " is NOT VALID" << std::endl;
    throw cet::exception("rawFragments NOT VALID");
  }

  lbne::TpcNanoSlice::Header::nova_timestamp_t firstTimestamp;
  std::vector<std::pair< std::pair<unsigned int,unsigned int>, lbne::TpcNanoSlice::Header::nova_timestamp_t> > DigitsIndexList;
  auto digits = tpcFragmentToRawDigits(*rawFragments, DigitsIndexList, firstTimestamp, fChannelMap, fUseChannelMap, fDebug, fCompression, fZeroThreshold);

  // Make a flat rce tree.....
  Reset();
  DigSize = digits.size();
  NSamples = digits[0].Samples();
  if (NSamples && fMakeTree) {
    std::cout << "Digits has size " << digits.size() << " digits[0] has " << digits[0].Samples() << std::endl;
    dune::DetPedestalDUNE pedestals("dune35t");
    pedestals.SetDetName("dune35t");
    pedestals.SetUseDefaults(false);
    pedestals.SetUseDB(true);
    pedestals.Update(evt.run());
    
    for (int dig=0; dig<DigSize; ++dig ) {
      int Chan = digits[dig].Channel();
      Channel[dig]  = Chan;
      Pedestal[dig] = pedestals.PedMean(Chan);
      for (int tick=0; tick<NSamples; ++tick) {
	ADCs[dig][tick] = digits[dig].ADC(tick);
      }
    }
    fTree->Fill();
  }

  art::Timestamp this_time_stamp = DAQToOffline::make_art_timestamp_from_nova_timestamp(firstTimestamp);
  std::cout << "JPD: this_time_stamp: " << this_time_stamp.value() << std::endl;
  std::cout << "JPD: event.time().value(): " << evt.time().value() << std::endl;

  evt.put(std::make_unique<decltype(digits)>(std::move(digits)), fOutputDataLabel);
}

void DAQToOffline::TpcDAQToOffline::Reset() {
  for (int ii=0; ii<MaxChannels; ++ii) {
    Channel[ii]  = -1;
    Pedestal[ii] = -1;
    for (int kk=0; kk<MaxSamples; ++kk) {
      ADCs[ii][kk] = -1;
    }
  }
}

DEFINE_ART_MODULE(DAQToOffline::TpcDAQToOffline)
