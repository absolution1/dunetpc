// -*- mode: c++; c-basic-offset: 2; -*-
////////////////////////////////////////////////////////////////////////
// Class:       SSPTriggerAna
// Module Type: producer
// File:        SSPTriggerAna_module.cc
//
// Quickly analyze raw data trigger rate in the SSP
//
// Alex Himmel ahimmel@fnal.gov (modified by Celio Moura camj@fnal.gov)
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <set>
#include <iomanip>

//lbne-artdaq includes
#include "lbne-raw-data/Overlays/SSPFragment.hh"
#include "lbne-raw-data/Overlays/anlTypes.hh"
#include "artdaq-core/Data/Fragment.hh"

//larsoft includes
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "larcore/Geometry/Geometry.h"

//daqinput35t includes

#include "utilities/UnpackFragment.h"
#include "SSPReformatterAlgs.h"

/*camj_includes*/
#include "TH1.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

namespace DAQToOffline {
  class SSPTriggerAna;
}

class DAQToOffline::SSPTriggerAna : public art::EDAnalyzer {
public:
  explicit SSPTriggerAna(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  void analyze(art::Event const & evt) override;
  void reconfigure(fhicl::ParameterSet const& pset);
  void printParameterSet();


   // Plugins should not be copied or assigned.
  SSPTriggerAna(SSPTriggerAna const &) = delete;
  SSPTriggerAna(SSPTriggerAna &&) = delete;
  SSPTriggerAna & operator = (SSPTriggerAna const &) = delete;
  SSPTriggerAna & operator = (SSPTriggerAna &&) = delete;
 
private:
  void beginJob() override;
  void endJob  () override;
  //void beginEvent(art::EventNumber_t eventNumber);
  //void endEvent  (art::EventNumber_t eventNumber);
  void beginRun(art::Run const& run) override;
  void endRun  (art::Run const& run) override;

  std::string fFragType;
  std::string fRawDataLabel;
  std::string fOutputDataLabel;
  
  SSPReformatterAlgs sspReform;

  unsigned long int firstTime;
  unsigned long int lastTime;
  std::map<int, long int> triggerCount;
  std::map<int, long int> triggerCountHeaders;
  std::map<int, long int> triggerCountWaveforms;

  TH1D *fTriggerRateHist;
  TH1D *fTriggerRateHistHeaders;
  TH1D *fTriggerRateHistWaveforms;

};


DAQToOffline::SSPTriggerAna::SSPTriggerAna(fhicl::ParameterSet const & pset)
                                         : art::EDAnalyzer(pset),
                                           sspReform(pset.get<fhicl::ParameterSet>("SSPReformatter"))
{

  this->reconfigure(pset);

  //first_FirstSample = -1;
  //first_TimeStamp = -1;
}

void DAQToOffline::SSPTriggerAna::reconfigure(fhicl::ParameterSet const& pset){

  fFragType           = pset.get<std::string>("FragType");
  fRawDataLabel       = pset.get<std::string>("RawDataLabel");

  //fDebug = pset.get<bool>("Debug");
  //fZeroThreshold=0;
  //fCompression=raw::kNone;

  printParameterSet();
  
}

void DAQToOffline::SSPTriggerAna::printParameterSet(){

  mf::LogDebug("SSPTriggerAna") << "===================================="   << "\n"
			       << "Parameter Set"                          << "\n"
			       << "===================================="   << "\n"
			       << "fFragType:        " << fFragType        << "\n"
			       << "fRawDataLabel:    " << fRawDataLabel    << "\n"
			       << "===================================="   << "\n";
}

void DAQToOffline::SSPTriggerAna::beginJob()
{
  //art::ServiceHandle<art::TFileService> tfs;
  //adc_values_ = tfs->make<TH1D>("adc_values","adc_values",4096,-0.5,4095.5);

  art::ServiceHandle<art::TFileService> tfs;
  fTriggerRateHist = tfs->make<TH1D>("triggerratehist",";Trigger Rate vs OpChannel;Rate (Hz)",116,-10,106);
  fTriggerRateHistHeaders = tfs->make<TH1D>("triggerratehist_headers",";Trigger Rate vs OpChannel;Rate (Hz)",116,-10,106);
  fTriggerRateHistWaveforms = tfs->make<TH1D>("triggerratehist_waveforms",";Trigger Rate vs OpChannel;Rate (Hz)",116,-10,106);

  firstTime = (((unsigned long int)1)<<63);
  lastTime = 0;
}

//void DAQToOffline::SSPTriggerAna::beginEvent(art::EventNumber_t /*eventNumber*/)

void DAQToOffline::SSPTriggerAna::beginRun(art::Run const& run)
{
  fTriggerRateHist->Reset();
  fTriggerRateHistHeaders->Reset();
  fTriggerRateHistWaveforms->Reset();
}

void DAQToOffline::SSPTriggerAna::endRun(art::Run const& run)
{
  long int deltaT = lastTime-firstTime;
  double deltaTus =  ((double)deltaT)/sspReform.ClockFrequency();

  fTriggerRateHist->Scale(1.e6/deltaTus);
  fTriggerRateHistHeaders->Scale(1.e6/deltaTus);
  fTriggerRateHistWaveforms->Scale(1.e6/deltaTus);
  
  fTriggerRateHist->SetTitle(Form("Run %i Trigger Rate",run.run()));
  fTriggerRateHistHeaders->SetTitle(Form("Run %i Header Trigger Rate",run.run()));
  fTriggerRateHistWaveforms->SetTitle(Form("Run %i Wavefrom Trigger Rate",run.run()));

  fTriggerRateHist->Write(Form("run_%i_trigger_rate",run.run()));
  fTriggerRateHistHeaders->Write(Form("run_%i_trigger_rate_headers",run.run()));
  fTriggerRateHistWaveforms->Write(Form("run_%i_trigger_rate_waveforms",run.run()));
  
}

//void DAQToOffline::SSPTriggerAna::endEvent(art::EventNumber_t eventNumber)

void DAQToOffline::SSPTriggerAna::endJob()
{
  //delete adc_values_;
  delete fTriggerRateHist;
  delete fTriggerRateHistHeaders;
  delete fTriggerRateHistWaveforms;
  
  long int deltaT = lastTime-firstTime;
  double deltaTus =  ((double)deltaT)/sspReform.ClockFrequency();


  mf::LogVerbatim("SSPTriggerAna") << "!! Trigger Rate Report." << std::endl;
  mf::LogVerbatim("SSPTriggerAna") << "!! Time: " << deltaTus / 60.e6 << " minutes." << std::endl;

  for (auto itr = triggerCount.begin(); itr != triggerCount.end(); itr++) {
    double freq = ((double)itr->second) / deltaTus * 1e6;
    mf::LogVerbatim("SSPTriggerAna") << "!!    Channel " << itr->first << ": " << std::setiosflags(std::ios::fixed) << std::setprecision(2) << std::setw(7) << freq << " Hz" << std::endl;
  }
  
  for (auto itr = triggerCountHeaders.begin(); itr != triggerCountHeaders.end(); itr++) {
    double freq = ((double)itr->second) / deltaTus * 1e6;
    mf::LogVerbatim("SSPTriggerAna") << "!!  H Channel " << itr->first << ": " << std::setiosflags(std::ios::fixed) << std::setprecision(2) << std::setw(7) << freq << " Hz" << std::endl;
  }
  
  for (auto itr = triggerCountWaveforms.begin(); itr != triggerCountWaveforms.end(); itr++) {
    double freq = ((double)itr->second) / deltaTus * 1e6;
    mf::LogVerbatim("SSPTriggerAna") << "!!  W Channel " << itr->first << ": " << std::setiosflags(std::ios::fixed) << std::setprecision(2) << std::setw(7) << freq << " Hz" << std::endl;
  }

  
  /*
  mf::LogInfo("SSPTriggerAna") << "firstSample:  " << firstTime << " samples\n"
                               << "lastSample:   " << lastTime  << " samples\n"
                               << "totalSamples: " << deltaT    << " samples\n"
                               << "totalTime:    " << deltaTus  << " us\n"
                               << "# Channels:   " << channels.size() << "\n"
                               << "# Triggers:   " << triggerCount << "\n"
                               << "Frequency:    " << freq << "kHz\n";
  */
}



void DAQToOffline::SSPTriggerAna::analyze(art::Event const & evt)
{

  //  std::cout<<"Event: "<<evt.event()<<"Run: "<<evt.run()<<std::endl;

  art::Handle<artdaq::Fragments> rawFragments;
  evt.getByLabel(fRawDataLabel, fFragType, rawFragments);

  // Check if there is SSP data in this event
  // Don't crash code if not present, just don't save anything
  try { rawFragments->size(); }
  catch(std::exception e) {
    mf::LogWarning("SSPTriggerAna") << "WARNING: Raw SSP data not found in event " << evt.event();
    return;
  }

  // Check that the data is valid
  if(!rawFragments.isValid()){
    mf::LogError("SSPTriggerAna") << "Run: " << evt.run()
				 << ", SubRun: " << evt.subRun()
				 << ", Event: " << evt.event()
				 << " is NOT VALID";
    throw cet::exception("raw NOT VALID");
    return;
  }



  unsigned int numFragments = rawFragments->size();

  for (size_t idx = 0; idx < numFragments; ++idx) {
    const auto& frag((*rawFragments)[idx]);
    lbne::SSPFragment sspf(frag);

    unsigned int nTriggers = sspReform.CheckAndGetNTriggers(frag, sspf);
      
    const unsigned int* dataPointer = sspf.dataBegin();

        
    for (unsigned int triggersProcessed = 0;
         (nTriggers==0 || triggersProcessed < nTriggers) && dataPointer < sspf.dataEnd();
         ++triggersProcessed) {
      
      //
      // The elements of the OpDet Pulse
      //
      unsigned short     OpChannel = -1;       ///< Derived Optical channel
      unsigned long      FirstSample = 0;      ///< first sample time in ticks
        

      // Load the event header, advance the pointer
      auto daqHeader = sspReform.GetHeaderAndAdvance(dataPointer);
      //const SSPDAQ::EventHeader* daqHeader=reinterpret_cast<const SSPDAQ::EventHeader*>(dataPointer);
      //dataPointer += sizeof(SSPDAQ::EventHeader)/sizeof(unsigned int);

      // Get ADC Count, create pointer to adcs
      unsigned int nADC = sspReform.GetWaveformLength(daqHeader);

      //get the information from the header
      try {
        OpChannel = sspReform.GetOpChannel(daqHeader);

        FirstSample = sspReform.GetGlobalFirstSample(daqHeader);
        //TimeStamp = ((double)FirstSample)/fNOvAClockFrequency;

        if (FirstSample < 1e16) {
          sspReform.PrintHeaderInfo(daqHeader);
          mf::LogInfo("SSPTriggerAna") << "Problem timestamp at " << FirstSample << std::endl;
          continue;
        }
      }
      catch (cet::exception e) {
        continue;
      }

      firstTime = std::min(firstTime, FirstSample);
      lastTime  = std::max(lastTime,  FirstSample);

      triggerCount[OpChannel]++;
      fTriggerRateHist->Fill(OpChannel);

      if (nADC == 0) {
        // Header only
        triggerCountHeaders[OpChannel]++;
        fTriggerRateHistHeaders->Fill(OpChannel);
      }
      else {
        // Waveform to skip
        triggerCountWaveforms[OpChannel]++;
        fTriggerRateHistWaveforms->Fill(OpChannel);
        
        // Advance the dataPointer to the next header
        dataPointer+=nADC/2;
      }

      
    } // End of loop over triggers
  } // End of loop over fragments (rawFragments)

    
}

DEFINE_ART_MODULE(DAQToOffline::SSPTriggerAna)


