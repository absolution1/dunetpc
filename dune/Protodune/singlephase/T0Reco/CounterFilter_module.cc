////////////////////////////////////////////////////////////////////////
// Class:       CounterFilter
// Module Type: filter
// File:        CounterFilter_module.cc
//
// Generated at Tue Aug 16 08:12:35 2016 by Matthew Thiesse using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include <memory>
#include <vector>

namespace dune {
  class CounterFilter;
}

class dune::CounterFilter : public art::EDFilter {
public:
  explicit CounterFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CounterFilter(CounterFilter const &) = delete;
  CounterFilter(CounterFilter &&) = delete;
  CounterFilter & operator = (CounterFilter const &) = delete;
  CounterFilter & operator = (CounterFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) ;

private:

  bool OppositeEW(std::vector<unsigned int> c);

  std::string fT0ModuleLabel;
  
};


dune::CounterFilter::CounterFilter(fhicl::ParameterSet const & p) : EDFilter{p}
{
  this->reconfigure(p);
}

bool dune::CounterFilter::filter(art::Event & e)
{
  bool valid = false;

  auto t0Handle = e.getHandle< std::vector< anab::T0> >(fT0ModuleLabel);
  if (t0Handle)
    {

      art::FindManyP<raw::ExternalTrigger> triggers(t0Handle,e,fT0ModuleLabel);

      for (size_t i_t0 = 0; i_t0 < t0Handle->size(); i_t0++)
	{
	  art::Ptr<anab::T0> pt0(t0Handle,i_t0);
	  std::vector< art::Ptr<raw::ExternalTrigger> > trigvec = triggers.at(i_t0);
	  if (trigvec.size() != 3) continue;

	  int contains_111 = 0, contains_112 = 0, contains_113 = 0;
	  int contains_Ntrigs = 0, contains_NU = 0, contains_NL = 0, contains_SU = 0, contains_SL = 0;
	  int contains_EL = 0, contains_WU = 0, contains_TEL = 0;
	  for (auto const &trig : trigvec)
	    {
	      unsigned int trigID = trig->GetTrigID();
              // for c2: unsigned int trigID is always >= 0
	      //if (trigID >= 0 && trigID <= 5) contains_SL++;
	      if (trigID <= 5) contains_SL++;
	      if (trigID >= 6 && trigID <= 15) contains_EL++;
	      if (trigID >= 16 && trigID <= 21) contains_NL++;
	      if (trigID >= 22 && trigID <= 27) contains_NU++;
	      if (trigID >= 28 && trigID <= 37) contains_WU++;
	      if (trigID >= 38 && trigID <= 43) contains_SU++;
	      if (trigID >= 44 && trigID <= 92) contains_TEL++;
	      if (trigID == 111) contains_111++;
	      if (trigID == 112) contains_112++;
	      if (trigID == 113) contains_113++;
	      contains_Ntrigs++;
	    } // end loop over trigvec
	  if (contains_111 + contains_112 + contains_113 != 1) continue;  // too many/few coincidences!
	  if (contains_TEL && 
	      (contains_NU || contains_NL || contains_SU || contains_SL || contains_EL || contains_WU)) continue;  // track probably doesn't go through detector
	  if (contains_Ntrigs != 3) continue;  // too much/little going on!
	  if (contains_111 && (contains_NU || contains_NL || contains_SU || contains_SL)) continue;  // 111 should not have NU/NL/SU/SL                                    
	  if (contains_112 && (contains_EL || contains_WU || contains_SU || contains_NL)) continue;  // 112 should not have EL/WU/SU/NL                                    
	  if (contains_113 && (contains_EL || contains_WU || contains_NU || contains_SL)) continue;  // 113 should not have EL/WU/NU/SL                                    
	  if (contains_111 && (!contains_EL || !contains_WU)) continue;  // incomplete trigger                                                                             
	  if (contains_112 && (!contains_NU || !contains_SL)) continue;  // incomplete trigger                                                                             
	  if (contains_113 && (!contains_SU || !contains_NL)) continue;  // incomplete trigger

	  std::vector<unsigned int> counterIDs;
	  unsigned int trignum = 0;
	  for (auto const &trig : trigvec)
	    {
	      unsigned int trigID = trig->GetTrigID();
	      if (trigID >= 44 && trigID <= 100) continue;
	      if (trigID >= 111 && trigID <= 113)
		{
		  trignum = trigID;
		  continue;
		}
	      counterIDs.push_back(trigID);
	    }
	  if (counterIDs.size() != 2) continue;
	  if (trignum == 0) continue;

	  if (trignum == 111 && OppositeEW(counterIDs)) 
	    {
	      std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
	      std::cout << "Event # " << e.event() << std::endl;
	      std::cout << " counter IDs " << counterIDs[0] << " and " << counterIDs[1] << std::endl;
	      std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
	      valid = true;

	    } 
	}
    }
  return valid;
}

bool dune::CounterFilter::OppositeEW(std::vector<unsigned int> c)
{
  if (c.size() != 2) return false;
  unsigned int c1 = c[0];
  unsigned int c2 = c[1];
  if (c1==c2) return false;
  if (c1%22 == c2 || c2%22 == c1) return true;
  return false;
}

void dune::CounterFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fT0ModuleLabel = p.get<std::string>("T0ModuleLabel");
}

DEFINE_ART_MODULE(dune::CounterFilter)
