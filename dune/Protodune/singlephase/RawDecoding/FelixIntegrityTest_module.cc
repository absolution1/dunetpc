// art includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"

// artdaq and dune-raw-data includes
#include "dune-raw-data/Overlays/FelixFragment.hh"
#include "artdaq-core/Data/Fragment.hh"
#include "artdaq-core/Data/ContainerFragment.hh"
#include "dune-raw-data/Overlays/FragmentType.hh"
#include "dune-raw-data/Services/ChannelMap/PdspChannelMapService.h"

// larsoft includes
#include "lardataobj/RawData/RawDigit.h"

// ROOT includes
#include "TH1.h"

// C++ Includes
#include <memory>
#include <iostream>
#include <iomanip>

namespace dune {
  class FelixIntegrityTest;
}

class dune::FelixIntegrityTest : public art::EDAnalyzer {
public:
  explicit FelixIntegrityTest(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resoufelix use.

  // Plugins should not be copied or assigned.
  FelixIntegrityTest(FelixIntegrityTest const &) = delete;
  FelixIntegrityTest(FelixIntegrityTest &&) = delete;
  FelixIntegrityTest & operator = (FelixIntegrityTest const &) = delete;
  FelixIntegrityTest & operator = (FelixIntegrityTest &&) = delete;

  // Required functions.
  void analyze(const art::Event & evt) override;
  void beginJob() override;
  void endJob() override;

  // Error metrics
  struct ErrorMetrics {
    uint64_t sequenceID;
    uint64_t fragmentID;
    uint64_t type;
    uint64_t timestamp;

    dune::FelixFragmentBase::Metadata meta;
    uint64_t crate_no;
    uint64_t slot_no;
    uint64_t fiber_no;

    bool meta_err;
    bool timestamp_err;
    bool convert_count_err;
    bool error_fields_set;

    bool bad;

    void print() const {
      std::cout
        << "SequenceID: " << sequenceID
        << "  fragmentID: " << fragmentID
        << "  fragmentType: " << type
        << "  Timestamp: " << timestamp
        << "  Crate number: " << crate_no
        << "  Slot number: " << slot_no
        << "  Fiber number: " << fiber_no << "\n\n";
      std::cout << "Metadata error: ";
      meta_err? std::cout << "YES\n" : std::cout << "NO\n";
      std::cout << "Timestamp error: ";
      timestamp_err? std::cout << "YES\n" : std::cout << "NO\n";
      std::cout << "Convert count error: ";
      convert_count_err? std::cout << "YES\n" : std::cout << "NO\n";
                // << "Error fields set: " << error_fields_set? "YES" : "NO\n";
    }
  };

private:
  ErrorMetrics _process(const artdaq::Fragment& frag);

  // Variables read from the fcl file
  std::string _input_label;
  bool _expect_container_fragments;

  // Keeping track of fragment metadata
  dune::FelixFragmentBase::Metadata run_meta = {0xcba};

  // WIB constants
  const uint64_t timestamp_increase = 25;

  // COLDATA constants
  const uint16_t convert_count_increase = 1;
  std::vector<ErrorMetrics> test_results;
  unsigned n_good_frags = 0;
  unsigned n_bad_frags = 0;
};


dune::FelixIntegrityTest::FelixIntegrityTest(fhicl::ParameterSet const & pset)
  : EDAnalyzer(pset),
    _input_label(pset.get<std::string>("RawDataLabel")),
    _expect_container_fragments(pset.get<bool>("ExpectContainerFragments", true)) {}

void dune::FelixIntegrityTest::beginJob(){
}

void dune::FelixIntegrityTest::analyze(const art::Event & evt){
  std::cout << "-------------------- FELIX Integrity Test -------------------";

  if (_expect_container_fragments) {
    art::InputTag itag1(_input_label, "ContainerFELIX");
    auto cont_frags = evt.getHandle<artdaq::Fragments>(itag1);
    art::EventNumber_t eventNumber = evt.event();
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    try { cont_frags->size(); }
    catch(std::exception const&) {
      std::cout << "WARNING: Container FELIX data not found in event " << eventNumber << std::endl;
      return;
    }
    //Check that the data is valid
    if (!cont_frags){
      MF_LOG_ERROR("FelixIntegrityTest")
          << "Run: " << evt.run()
          << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
          << " Container Fragment data invalid";
    }

    for (auto const& cont : *cont_frags)
    {
      artdaq::ContainerFragment cont_frag(cont);
      for (size_t ii = 0; ii < cont_frag.block_count(); ++ii)
      {
        const ErrorMetrics this_err = _process(*cont_frag[ii]);
        test_results.push_back(this_err);
        this_err.bad? ++n_bad_frags : ++n_good_frags;
      }
    }
  }
  else
  {
    art::InputTag itag2(_input_label, "FELIX");
    auto frags = evt.getHandle<artdaq::Fragments>(itag2);
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    art::EventNumber_t eventNumber = evt.event();
    try { frags->size(); }
    catch(std::exception const&) {
      std::cout << "WARNING: Raw FELIX data not found in event " << eventNumber << std::endl;
      return;
    }

    //Check that the data is valid
    if (!frags){
      MF_LOG_ERROR("FelixIntegrityTest")
          << "Run: " << evt.run()
          << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
          << " Fragment data invalid";
    }

    for(auto const& frag: *frags)
    {
      const ErrorMetrics this_err = _process(frag);
      test_results.push_back(this_err);
      this_err.bad? ++n_bad_frags : ++n_good_frags;
    }
  }
}

void dune::FelixIntegrityTest::endJob() {
  const unsigned long n_frags = n_bad_frags + n_good_frags;
  std::cout
      << "\nProcessed " << n_bad_frags+n_good_frags
      << " FELIX Fragments.\nFound " << n_good_frags
      << " good fragments. Success rate: "
      << (double)n_good_frags/n_frags << "/1.\n\n";

  // Create structs for easier looping.
  struct Location {
    uint64_t crate_no, slot_no, fiber_no;
    bool operator<(const Location& b) const {
      if(crate_no == b.crate_no && slot_no == b.slot_no) {
        return fiber_no < b.fiber_no;
      } else if(crate_no == b.crate_no) {
        return slot_no < b.slot_no;
      }
      return crate_no < b.crate_no;
    }
  };
  struct Errors {
    unsigned long meta_err, timestamp_err, convert_count_err, error_fields_set;
    void operator+=(const Errors& other) {
      meta_err += other.meta_err;
      timestamp_err += other.timestamp_err;
      convert_count_err += other.convert_count_err;
      error_fields_set += other.error_fields_set;
    }
  };
  // Loop over collected error metrics to find their origin
  std::map<Location, Errors> errMap;
  for(const ErrorMetrics& errm : test_results) {
    Location loc = {errm.crate_no, errm.slot_no, errm.fiber_no};
    Errors err = {(unsigned long)errm.meta_err, (unsigned long)errm.timestamp_err,
                  (unsigned long)errm.convert_count_err, (unsigned long)errm.error_fields_set};
    errMap[loc] += err;
  }
  // Print the error rate in a nice table
  std::cout << "Error rates\n";
  std::cout << "Crate:Slot:Fiber | Metadata error | Timestamp error | Convert count error | Error fields set\n"
            << "--------------------------------------------------------------------------------------------\n";
  for(const std::pair<Location, Errors>& p : errMap) {
    std::cout << std::left << std::setw(16) << std::to_string(p.first.crate_no) + ":" + std::to_string(p.first.slot_no) + ":" + std::to_string(p.first.fiber_no) << " | ";
    if(p.second.meta_err) std::cout << std::setw(14) << (double)p.second.meta_err/n_frags << " | ";
    else std::cout << std::setw(14) << " " << " | ";
    if(p.second.timestamp_err) std::cout << std::setw(15) << (double)p.second.timestamp_err/n_frags << " | ";
    else std::cout << std::setw(15) << " " << " | ";
    if(p.second.convert_count_err) std::cout << std::setw(19) << (double)p.second.convert_count_err/n_frags << " | ";
    else std::cout << std::setw(19) << " " << " | ";
    if(p.second.error_fields_set) std::cout << std::setw(16) << (double)p.second.error_fields_set/n_frags;
    else std::cout << std::setw(16) << " ";

    std::cout << '\n';
  }
}

dune::FelixIntegrityTest::ErrorMetrics dune::FelixIntegrityTest::_process(const artdaq::Fragment& frag)
{
  // Load overlay class
  dune::FelixFragment flxfrag(frag);

  std::cout
      << "-------------------- Testing fragment -------------------" << '\n'
      << "SequenceID: " << frag.sequenceID()
      << "  fragmentID: " << frag.fragmentID()
      << "  fragmentType: " << (unsigned)frag.type()
      << "  Timestamp: " << frag.timestamp()
      << "  Crate number: " << (int)flxfrag.crate_no()
      << "  Slot number: " << (int)flxfrag.slot_no()
      << "  Fiber number: " << (int)flxfrag.fiber_no() << "\n\n";

  // Metadata tests
  const dune::FelixFragmentBase::Metadata* meta = frag.metadata<dune::FelixFragmentBase::Metadata>();
  bool meta_failed = false;
  // Record the first metadata, compare otherwise
  if(run_meta.control_word == 0xcba) {
    run_meta = *meta;
  } else {
    meta_failed |= meta->control_word != run_meta.control_word
                || meta->version != run_meta.version
                || meta->reordered != run_meta.reordered
                || meta->compressed != run_meta.compressed
                || meta->num_frames != run_meta.num_frames
                || meta->offset_frames != run_meta.offset_frames
                || meta->window_frames != run_meta.window_frames;
    if(meta_failed) {
      std::cout
          << "Metadata error." << '\n'
          << "  This fragment's metadata: " << '\n'
          << "      Control word: " << meta->control_word
          << "      Version: " << meta->version
          << "      Reordered: " << meta->reordered
          << "      Compressed: " << meta->compressed
          << "      Number of frames: " << meta->num_frames
          << "      Offset frames: " << meta->offset_frames
          << "      Window frames: " << meta->window_frames << '\n'
          << "  Expected metadata: " << '\n'
          << "      Control word: " << run_meta.control_word
          << "      Version: " << run_meta.version
          << "      Reordered: " << run_meta.reordered
          << "      Compressed: " << run_meta.compressed
          << "      Number of frames: " << run_meta.num_frames
          << "      Offset frames: " << run_meta.offset_frames
          << "      Window frames: " << run_meta.window_frames << "\n\n";
    } else {
      std::cout
          << "Metadata test successful." << "\n\n";
    }
  }

  // Timestamp tests
  bool timestamp_failed = false;
  // Compare to metadata: first frame must be within 25 counts of the fragment timestamp
  if(frag.timestamp() - meta->offset_frames*timestamp_increase - flxfrag.timestamp(0) >= timestamp_increase) {
    timestamp_failed = true;
    std::cout
        << "First timestamp matching error." << '\n'
        << "  This fragment's timestamp: " << frag.timestamp()
        << "  First frame's timestamp: " << flxfrag.timestamp(0)
        << "  Expected offset (-24 or less): " << meta->offset_frames*timestamp_increase
        << "  Offset: " << frag.timestamp() - flxfrag.timestamp(0) << "\n\n";
  }
  // Make sure the correct number of frames is contained when compared to the metadata
  if(flxfrag.total_frames() != meta->window_frames) {
    timestamp_failed = true;
    std::cout
        << "Trigger window error." << '\n'
        << "  This fragment's expected number of frames: " << meta->window_frames
        << "  Number of frames available: " << flxfrag.timestamp(0) << "\n\n";
  }
  // Go through all timestamps and check their increase
  for(unsigned fi = 1; fi < flxfrag.total_frames(); ++fi) {
    if(flxfrag.timestamp(fi) - flxfrag.timestamp(fi-1) != timestamp_increase) {
      timestamp_failed = true;
      std::cout
          << "Timestamp increase error." << '\n'
          << "  Timestamp of frame " << fi - 1 << ": " << flxfrag.timestamp(fi-1)
          << "  Timestamp of frame " << fi << ": " << flxfrag.timestamp(fi)
          << "  Difference: " << flxfrag.timestamp(fi) - flxfrag.timestamp(fi-1) << "\n\n";
      break;
    }
  }
  if(!timestamp_failed) {
    std::cout
        << "Timestamp test successful." << "\n\n";
  }

  // Convert count test
  bool convert_count_failed = false;
  // Check the increase of all convert counts between frames
  for(unsigned fi = 1; fi < flxfrag.total_frames(); ++fi) {
    // The first two counts and last two counts need to be identical
    for(int bi = 0; bi < 2; ++bi) {
      if(flxfrag.coldata_convert_count(fi, 2*bi) != flxfrag.coldata_convert_count(fi, 2*bi + 1)
         || (flxfrag.coldata_convert_count(fi, bi) - flxfrag.coldata_convert_count(fi - 1, bi)
             != convert_count_increase
             && flxfrag.coldata_convert_count(fi, bi) - flxfrag.coldata_convert_count(fi - 1, bi)
             != convert_count_increase - (1<<16))) {
        convert_count_failed = true;
        std::cout
            << "COLDATA convert count increase error in frame " << fi << ".\n"
            << "  Count 1 of frame " << fi - 1 << ": " << flxfrag.coldata_convert_count(fi-1, 0)
            << "  Count 2 of frame " << fi - 1 << ": " << flxfrag.coldata_convert_count(fi-1, 1)
            << "  Count 3 of frame " << fi - 1 << ": " << flxfrag.coldata_convert_count(fi-1, 2)
            << "  Count 4 of frame " << fi - 1 << ": " << flxfrag.coldata_convert_count(fi-1, 3) << '\n'
            << "  Count 1 of frame " << fi << ": " << flxfrag.coldata_convert_count(fi, 0)
            << "  Count 2 of frame " << fi << ": " << flxfrag.coldata_convert_count(fi, 1)
            << "  Count 3 of frame " << fi << ": " << flxfrag.coldata_convert_count(fi, 2)
            << "  Count 4 of frame " << fi << ": " << flxfrag.coldata_convert_count(fi, 3) << '\n'
            << "  Difference: "
            << flxfrag.coldata_convert_count(fi, 0) - flxfrag.coldata_convert_count(fi-1, 0) << "\n\n";
        break;
      }
    }
    if(convert_count_failed) break;
  }
  if(!convert_count_failed) {
    std::cout
        << "COLDATA convert count test successful." << "\n\n";
  }

  // Frame error fields test
  bool error_field_failed = false;
  // Check all error fields in all frames without distinction for now
  // // TODO: Look into what errors are relevant!
  // for(unsigned fi = 0; fi < 0/*flxfrag.total_frames()*/; ++fi) {
  //   error_field_failed |= flxfrag.mm(fi) || flxfrag.oos(fi) || flxfrag.wib_errors(fi);
  //   for(unsigned bi = 0; bi < 4; ++bi) {
  //     error_field_failed |= flxfrag.s1_error(fi, bi) || flxfrag.s2_error(fi, bi)
  //                           || flxfrag.error_register(fi, bi);
  //   }
  //
  //   if(error_field_failed) {
  //     std::cout
  //         << "One or more error fields set in frame " << fi << ".\n"
  //         << "  Mismatch: " << (int)flxfrag.mm(fi)
  //         << "  Out of sync: " << (int)flxfrag.oos(fi)
  //         << "  WIB errors: " << (int)flxfrag.wib_errors(fi) << '\n';
  //     for(unsigned bi = 0; bi < 4; ++bi) {
  //       std::cout
  //           << "  Block " << bi+1 << ":\n"
  //           << "    Stream 1 error: " << (int)flxfrag.s1_error(fi, bi)
  //           << "    Stream 2 error: " << (int)flxfrag.s2_error(fi, bi)
  //           << "    Error register: " << (int)flxfrag.error_register(fi, bi) << '\n';
  //     }
  //     std::cout << '\n';
  //     break;
  //   }
  // }

  //Output error metrics
  ErrorMetrics outem;
  outem.sequenceID = frag.sequenceID();
  outem.fragmentID = frag.fragmentID();
  outem.type = frag.type();
  outem.timestamp = frag.timestamp();
  outem.crate_no = flxfrag.crate_no();
  outem.slot_no = flxfrag.slot_no();
  outem.fiber_no = flxfrag.fiber_no();
  outem.meta = *meta;
  outem.meta_err = meta_failed;
  outem.timestamp_err = timestamp_failed;
  outem.convert_count_err = convert_count_failed;
  outem.error_fields_set = error_field_failed;

  outem.bad = timestamp_failed || convert_count_failed || error_field_failed;

  return outem;
}

DEFINE_ART_MODULE(dune::FelixIntegrityTest)
